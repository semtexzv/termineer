{{! Tools Template Partial }}
{{!
  This is a partial template containing only tool definitions.
  It can be included in other templates using inclusion syntax
  
  This template uses the iftool helper for conditional content based on tool enablement.
  Variable: enabled_tools - array of lowercase tool names
}}

{{#iftool "shell"}}

### Shell
Execute shell commands on the user's system
{{#tool "shell"}}[command]{{/tool}}

Example:
{{#tool "shell"}}ls -la{{/tool}}

Example response:
### Shell
Execute shell commands on the user's system:
{{#tool "shell"}} [command]{{/tool}}

Example:
{{#tool "shell"}}ls -la{{/tool}}

{{#done "shell" 0}}
drwxr-xr-x  14 mhornicky  primarygroup    448 Feb 27 22:11 .
drwxr-x---+ 89 mhornicky  primarygroup   2848 Feb 27 21:59 ..
-rw-r--r--@  1 mhornicky  primarygroup   2169 Feb 27 22:09 .termineer
-rw-r--r--   1 mhornicky  primarygroup    127 Feb 27 13:44 .env
-rw-r--r--@  1 mhornicky  primarygroup    175 Feb 27 10:48 .env.example
{{/done}}

Long-running commands can be interrupted in two ways:
1. **LLM interruption**: You'll be periodically prompted to decide whether to interrupt based on output patterns. When interrupting, provide a concise reason with:
`<interrupt>Your one-sentence reason here</interrupt>`

2. **User interruption**: Users can press Ctrl+C to manually stop the command

Use intelligent interruption to avoid wasting time on commands that have already provided sufficient information.

When to use:
- Explore directories and file structures
- Run build commands, tests, or package managers
- Check environment settings or configurations
{{/iftool}}

{{#iftool "read"}}
### Read
Read the contents of files or list directory contents:
{{#tool "read"}}[offset=N] [limit=M] [filepath(s) or directory path]{{/tool}}
- The `offset` parameter (optional) specifies the starting line number (0-indexed)
- The `limit` parameter (optional) specifies the maximum number of lines to read
- Multiple files can be read at once (space-separated) when not using offset/limit
- For large files, only the first and last few lines will be shown
- When a directory path is provided, lists all files and subdirectories in that directory

Examples:
{{#tool "read"}}/etc/hosts{{/tool}}

{{#done "read" 0}}/etc/hosts
File: (all 7 lines)
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b ip6-localnet
fc00:db20:35b:7399::5 ip6-mcastprefix
fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b ip6-allnodes
fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b ip6-allrouters
192.168.1.100 ubuntu-vm
{{/done}}

{{#tool "read"}}offset=0 limit=1 /etc/hosts{{/tool}}

{{#done "read" 0}}
127.0.0.1 localhost
{{/done}}

#### Other examples:
{{#tool "read"}}file1.txt file2.txt file3.txt{{/tool}}
{{#tool "read"}}/path/to/directory{{/tool}}

When to use:
- Examine code, configuration files, logs, or documentation
- List directory contents to explore project structure
- Understand existing implementations before making changes
- Compare multiple related files at once
- Verify changes after they've been made
{{/iftool}}

{{#iftool "write"}}
### Write
Write content to a file:
{{#tool "write"}}[filepath]
[content on multiple lines]
{{/tool}}

Example:
{{#tool "write"}}/tmp/example.txt
This is example content
that spans multiple lines
in the file.
{{/tool}}

{{#done "write" 0}}
File written successfully.
{{/done}}

When to use:
- Create new files (scripts, configs, documentation)
- Generate complete replacements for existing files
- Output results or generate reports
{{/iftool}}

{{#iftool "patch"}}
### Patch
Update file content by replacing text
{{#tool "patch"}}[filepath]
{{#patch}}
[text before change]
{{else}}
[text after change]
{{/patch}}

{{/tool}}

{{#done "patch" 0}}
File patched successfully.
{{/done}}

Example:
{{#tool "patch"}}src/main.rs
{{#patch}}
[text before change]
{{else}}
{{/patch}}

{{/tool}}

{{#done "patch" 0}}

File patched successfully.
{{/done}}

When to use:
- Make targeted changes to specific sections of code
- Fix bugs or implement new features in existing files
- Update configuration settings without rewriting entire files
{{/iftool}}

{{#iftool "fetch"}}
### Fetch
Retrieve content from web URLs:
{{#tool "fetch"}}URL{{/tool}}

Example:
{{#tool "fetch"}}https://example.com{{/tool}}

{{#done "fetch" 0}}

Fetched from https://example.com:

# Example Domain

This domain is for use in illustrative examples in documents.
{{/done}}

When to use:
- **CRUCIAL FOR RESEARCH**: Directly access official documentation, specifications, and guides
- Retrieve complete documentation pages when you need comprehensive details
- Get information from public APIs, GitHub repositories, and developer resources
- Access README files, usage guides, and API documentation
- Study code examples, tutorials, and implementation patterns from authoritative sources
- Examine error code references, troubleshooting guides, and FAQs
- Incorporate external reference material into your analysis and solutions
- Follow up on promising URLs discovered via search to get full content
- Access community wikis, official forums, and project documentation

Effective fetch workflow:
1. First use search to find relevant resources
2. Identify the most authoritative or helpful URLs from search results
3. Use fetch to retrieve complete content from those URLs
4. Extract key information, patterns, and solutions from the fetched content
5. Apply the knowledge to the specific problem you're solving

{{/iftool}}

{{#iftool "search"}}
### Search
Search the web using Google Search API:
{{#tool "search"}}[search query]{{/tool}}

Example:
{{#tool "search"}}rust programming language{{/tool}}

{{#done "search" 0}}
Search results for "rust programming language":

1. The Rust Programming Language - Rust Programming Language
   URL: https://doc.rust-lang.org/book/
   The Rust Programming Language is an introductory book about Rust, a programming language that helps you write faster, more reliable software.

2. Rust Programming Language
   URL: https://www.rust-lang.org/
   Rust is a multi-paradigm, general-purpose programming language that emphasizes performance, type safety, and concurrency.

3. Learn Rust - Rust Programming Language
   URL: https://www.rust-lang.org/learn
   Learn Rust programming with official documentation, books, and practice exercises.

Total results: 9,850,000
Search engine time: 0.25 seconds
Total search time: 418.43ms
{{/done}}

When to use:
- **ESSENTIAL FIRST STEP**: Begin most tasks by searching for relevant documentation, tutorials and best practices
- Research technical topics, libraries, frameworks, and programming concepts
- Find official documentation, API references, and language specifications
- Explore common patterns, architectures, and implementation approaches
- Discover solutions to error messages, bugs, and implementation challenges
- Research compatibility issues, version differences, and migration guides
- Investigate security best practices and potential vulnerabilities
- Find community discussions about pros/cons of different approaches
- Stay updated with latest developments and recommended practices

Search query tips:
- Be specific: "react useEffect dependency array" is better than "react hooks"
- Add context: "python argparse subcommands example" vs just "argparse"
- Include error messages: search for specific error text for faster solutions 
- Try multiple variations: "nodejs stream backpressure", "handling backpressure in nodejs"
{{/iftool}}

{{#iftool "screenshot"}}
### Screenshot
Capture a screenshot of the current screen or a specific window:
{{#tool "screenshot"}}[command] [identifier]{{/tool}}

Commands:
- No arguments - Captures all displays as separate images (default)
- `screen [index]` - Captures a specific screen by index number (0-based)
- `window [ID]` - Captures a specific window by ID (use `screendump` to get IDs)
- `window [Title]` - Captures a specific window by title match

Examples:

Capture all screens as separate images (default behavior):
{{#tool "screenshot"}}{{/tool}}

{{#done "screenshot" 0}}
[Multiple screen images will appear here]
{{/done}}

Capture a specific screen by index:
{{#tool "screenshot"}}screen 0{{/tool}}

{{#done "screenshot" 0}}
[Primary screen image will appear here]
{{/done}}

Capture a specific window by ID:
{{#tool "screenshot"}}window Safari:1{{/tool}}

{{#done "screenshot" 0}}
[Safari window image content will appear here]
{{/done}}

Capture a window by title match:
{{#tool "screenshot"}}window Downloads{{/tool}}

{{#done "screenshot" 0}}
[Downloads window image content will appear here]
{{/done}}

When to use:
- Multi-screen capture: Analyze all displays separately
- Single screen capture: Focus on a specific monitor
- Window capture: Focus on specific applications or UI elements
- Analyze visual elements using Claude's computer vision capabilities
- Get visual feedback about the state of applications
- Assist with troubleshooting UI issues
- Allow Claude to see and interpret UI elements
- Document the current state of applications

How it works:
- Default mode captures all displays as separate images
- Screen index mode captures a specific screen by number
- Window mode uses accessibility APIs to find and capture specific windows
- Works with the `screendump` tool which provides window IDs and structural information
- Uses the same window identification system as `screendump` (App:Index format)
- Images are automatically resized if needed to fit Claude's requirements
- Screenshots are encoded as base64 JPEG images and sent directly to Claude

For best results:
1. Use `screendump` (without arguments) to list available windows with their IDs
2. Use `screenshot window [ID]` to capture a specific window
3. Use `screendump window [ID]` to get the UI structure of the same window
{{/iftool}}

{{#iftool "input"}}
### Input
Send mouse and keyboard inputs to windows:
{{#tool "input"}}[command] [parameters]
[optional content for type command or sequence]
{{/tool}}

Commands:
- `click x y [window_id] [options]` - Click at x,y coordinates in a window
  - Options: `--right` (right click), `--middle` (middle click), `--double` (double-click)
- `type [window_id]` - Type text into a window (text follows on next lines)
- `key [modifiers+]key [window_id]` - Send keyboard shortcut (e.g., cmd+shift+t)
- `sequence [window_id]` - Execute a sequence of actions (one per line)

Examples:

Mouse click:
{{#tool "input"}}click 100 200 Terminal{{/tool}}

{{#done "input" 0}}
Clicked at coordinates (100, 200) in window 'Terminal'
{{/done}}

Mouse right-click:
{{#tool "input"}}click 300 400 Safari:1 --right{{/tool}}

{{#done "input" 0}}
Clicked at coordinates (300, 400) in window 'Safari:1'
{{/done}}

Type text:
{{#tool "input"}}type TextEdit:1
Hello, world! This is some text that will be typed into the window.
{{/tool}}

{{#done "input" 0}}
Typed text into window 'TextEdit:1'
{{/done}}

Keyboard shortcut:
{{#tool "input"}}key cmd+shift+t Chrome:1{{/tool}}

{{#done "input" 0}}
Sent keyboard shortcut to window 'Chrome:1'
{{/done}}

Action sequence:
{{#tool "input"}}sequence Safari:1
click 100 200
wait 500
type Hello, world!
key return
{{/tool}}

{{#done "input" 0}}
Action 1: Clicked at coordinates (100, 200) in window 'Safari:1'
Action 2: Waited for 500ms
Action 3: Typed text into window 'Safari:1'
Action 4: Sent keyboard shortcut to window 'Safari:1'
{{/done}}

When to use:
- Automate UI interactions in target applications
- Click on specific buttons or elements in windows
- Type text into form fields or editors
- Send keyboard shortcuts for application commands
- Create automation sequences for multi-step workflows
- Test user interfaces programmatically
- Interact with applications that don't have API access

How it works:
- Uses platform-specific accessibility APIs to send inputs to windows
- Works with `screendump` to identify window positions and IDs
- Window IDs use the App:Index format (e.g., Safari:1, Terminal:1)
- Uses secure permissions-based access to control applications
- Action sequences can combine clicks, typing, key presses, and wait times
- Handles focus and application activation automatically
{{/iftool}}

{{#iftool "screendump"}}
### Screendump
Capture the current UI structure as text using accessibility APIs:
{{#tool "screendump"}}[command] [identifier]{{/tool}}

Commands:
- No arguments - Lists all available windows with IDs (default)
- `fullscreen` - Captures all visible applications and windows
- `window [ID]` - Captures a specific window by ID
- `window [Title]` - Captures a specific window by title

Examples:

List all windows (default behavior):
{{#tool "screendump"}}{{/tool}}

{{#done "screendump" 0}}
Available Windows:
[Terminal:1] Terminal: termineer — -zsh — 80×24
[Safari:1] Safari: Claude AI - Safari
[Finder:1] Finder: Downloads
[VSCode:1] VSCode: screendump.rs

Use 'screendump window [ID]' or 'screendump window [Window Title]' to view details for a specific window.
{{/done}}

Capture details for a specific window using ID:
{{#tool "screendump"}}window Safari:1{{/tool}}

{{#done "screendump" 0}}
Window Details for 'Safari:1':
Application: Safari
Window: Claude AI - Safari
Position: 240, 150
Size: 1024×768

UI Elements:
  Element:
    Type: AXButton
    Description: Back
  Element:
    Type: AXTextField
    Value: https://claude.ai
{{/done}}

Capture details using window title:
{{#tool "screendump"}}window Downloads{{/tool}}

{{#done "screendump" 0}}
Window Details for 'Downloads':
Application: Finder
Window: Downloads
Position: 100, 100
Size: 800×600

UI Elements:
  Element:
    Type: AXList
    Description: File list
{{/done}}

When to use:
- List all accessible windows on the system
- Analyze the structure of specific application interfaces
- Extract information about UI elements and their properties
- Understand window layouts and hierarchies
- Identify accessibility information about windows and applications
- Get details about controls, buttons, and other interface elements
- Find specific UI elements for automation or analysis
- Compare UI structure across different applications

How it works:
- Uses platform-specific accessibility APIs to query UI structure
- On macOS, uses AppleScript with System Events to access UI elements
- Returns structured hierarchical data about windows and UI elements
- Provides details like element roles, properties, values, and relationships
- Complements the screenshot tool by providing structural information rather than visual representation
- Uses a consistent window identification system via App:Index IDs
{{/iftool}}

{{#iftool "mcp"}}
### MCP Servers

{{#if mcp_servers}}
The following Model Context Protocol (MCP) servers are available:
{{#each mcp_servers}}
- {{this}}
{{/each}}

For advanced operations, you can call MCP tools directly using:
```
mcp call <server_name> <tool_id>
{
  "param1": "value1",
  "param2": "value2"
}
```

You can view available tools on a server with:
```
mcp list <server_name>
```

Example:
{{#tool "mcp"}}list {{#each mcp_servers}}{{#if @first}}{{this}}{{/if}}{{/each}}{{/tool}}

{{else}}
No MCP servers are currently configured.
{{/if}}

When using MCP servers:
- Use the exact server names as shown above
- Format JSON parameters according to the tool's requirements
- Provide all required parameters for the tool
- Refer to available MCP servers when discussing capabilities
{{/iftool}}

{{#iftool "task"}}
### Task
Create a subtask to perform a specific goal
{{#tool "task"}}[parameters] task_name
[detailed task instructions on multiple lines]
{{/tool}}

Parameters (optional):
- `kind=TYPE`: Specify the agent kind to use for this task (e.g., kind=researcher)
- `include=PATTERN`: Include file(s) as context (supports glob patterns)

Available agent kinds:
{{available_kinds false}}

{{#done "task" 0}}

[Subtask output]
{{/done}}

Examples:
{{#tool "task"}}kind=code_implementer
Implement a login form validation script
Create a JavaScript function that validates:
- Email format
- Password strength (8+ chars, mixed case, numbers)
- Matching password confirmation field
{{/tool}}

{{#tool "task"}}kind=researcher include=src/config.rs
Research how configuration is managed in this codebase
Focus on how configuration options are defined, loaded and accessed
Create a comprehensive overview of the configuration system
{{/tool}}

{{#tool "task"}}kind=troubleshooter include=src/error.rs include=src/logging.rs
Debug the memory leak in user session handling
The application shows increasing memory usage over time
Memory grows with each user login/logout cycle
Focus on the session cleanup in auth module
{{/tool}}

When to use:
- Break down complex tasks into smaller, focused subtasks
- Run operations in isolation from the main conversation flow
- Process specialized tasks that require focused attention
- Create modular solutions to complex problems
- Parallelize research efforts (e.g., one task explores codebase while another researches documentation)

Best practices for effective task usage:
- Be highly specific about the subtask's objectives and expected outputs
- Provide clear success criteria so the subtask knows when it's complete
- Include relevant context from your main task to avoid redundant research
- Use for targeted research that can be performed independently
- Combine results from multiple subtasks for comprehensive solutions
{{/iftool}}

{{#iftool "agent"}}
### Agent
Create and communicate with other agents:
{{#tool "agent"}}[subcommand] [parameters] [name]

[content on multiple lines]
{{/tool}}

{{#done "agent" 1}}

[Result depends on subcommand]
{{/done}}

Subcommands:
- `create`: Create a new agent with optional parameters:
  - `kind=TYPE`: Specify the agent kind (e.g., kind=orchestrator)
- `send`: Send a message to another agent (by name or ID)

Examples:

1. Creating a new agent with default kind:
{{#tool "agent" }}create research_agent
Research the latest JavaScript frameworks and provide a summary
of their key features, performance characteristics, and use cases.
{{/tool}}

{{#done "agent" 0}}

Agent 'research_agent' created with ID: 2
Initial instructions sent to the agent.
{{/done}}

2. Creating a specialized agent with specific kind:
{{#tool "agent" }}create kind=codebase_explorer code_explorer
Explore the src/ directory and create a comprehensive map of:
1. Main components and their responsibilities
2. Key data structures and their relationships
3. Control flow for the main application paths
{{/tool}}

{{#done "agent" 0}}

Agent 'code_explorer' created with ID: 3
Initial instructions sent to the agent.
{{/done}}

2. Sending a message to another agent:
{{#tool "agent" 0}}send research_agent

Please also include information about TypeScript integration
in your framework comparison.
{{/tool}}

{{#done "agent" 0}}

Message sent to agent research_agent [ID: 2]
{{/done}}

When to use:
- Create specialized agents for parallel research or tasks
- Delegate complex subtasks to dedicated agents
- Enable collaborative problem-solving across multiple experts
- Create supervisor-worker agent structures
- Establish agent communication networks for complex workflows
{{/iftool}}

{{#iftool "wait"}}
### Wait
Pause the agent until a message is received:
{{#tool "wait"}}

[reason for waiting]
{{/tool}}

{{#done "wait" 0}}Resumed{{/done}}

Example:
{{#tool "wait"}}

Waiting for database query results from the database_agent
{{/tool}}

{{#done "wait" 1}}Resumed{{/done}}

When to use:
- Wait for messages from other agents
- Pause execution while waiting for external events
- Signal to users that you're ready for additional input
- Create synchronization points in multi-agent workflows
{{/iftool}}

{{#iftool "done"}}
### Done
Signal task completion with optional summary:
{{#tool "done"}}

[summary on multiple lines]
{{/tool}}

{{#done "done" 0}}{{/done}}

Use this tool when a task is complete to provide a final summary and end the conversation.

Example:
{{#tool "done"}}
Task completed. Created new file and configured settings.
All requested changes have been implemented successfully.
{{/tool}}

{{#done "done" 1}}{{/done}}
{{/iftool}}