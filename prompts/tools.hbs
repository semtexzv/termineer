{{! Tools Template Partial }}
{{!
  This is a partial template containing only tool definitions.
  It can be included in other templates using inclusion syntax
  
  This template uses the iftool helper for conditional content based on tool enablement.
  Variable: enabled_tools - array of lowercase tool names
  
  Tools are organized into the following categories:
  - System Tools: shell
  - File Operations: read, write, patch
  - Web Tools: fetch, search 
  - UI Automation: screenshot, screendump, input
  - Integration: mcp
  - Workflow: task, agent, wait, done
}}

{{! ================ SYSTEM TOOLS ================ }}
{{#iftool "shell"}}
### Shell
Execute shell commands on the user's system
{{#tool "shell"}}[command]{{/tool}}

The shell tool allows you to run commands directly on the user's system. It supports both simple commands and more complex scripts.

Features:
- **Streaming output**: Results appear in real-time as the command runs
- **Intelligent interruption**: You can decide when enough output has been produced
- **Multi-line scripts**: Include complex scripts directly in the tool body
- **Error handling**: Captures both stdout and stderr

Basic example:
{{#tool "shell"}}ls -la{{/tool}}

{{#done "shell" 0}}
drwxr-xr-x  14 mhornicky  primarygroup    448 Feb 27 22:11 .
drwxr-x---+ 89 mhornicky  primarygroup   2848 Feb 27 21:59 ..
-rw-r--r--@  1 mhornicky  primarygroup   2169 Feb 27 22:09 .termineer
-rw-r--r--   1 mhornicky  primarygroup    127 Feb 27 13:44 .env
-rw-r--r--@  1 mhornicky  primarygroup    175 Feb 27 10:48 .env.example

[COMMAND COMPLETED SUCCESSFULLY]
{{/done}}

Multi-line script example:
{{#tool "shell"}}
#!/bin/bash
# Search for specific files
echo "Searching for configuration files..."
find . -name "*.json" -type f | grep config
echo "Done!"
{{/tool}}

{{#done "shell" 0}}
Searching for configuration files...
./config.json
./package.json
Done!

[COMMAND COMPLETED SUCCESSFULLY]
{{/done}}

## Command Interruption

Long-running commands can be interrupted in two ways:

1. **LLM-based interruption**: For commands that produce a lot of output, you'll be periodically asked if you want to interrupt. When prompted, you can:

   - Continue execution:
     ```
     <continue/>
     ```
     
   - Interrupt with a reason:
     ```
     <interrupt>Sufficient matches found in search results</interrupt>
     ```
     
2. **User interruption**: The user can press Ctrl+C to manually stop the command at any time

When interrupted, you'll see something like:
```
[COMMAND INTERRUPTED: Sufficient information gathered]
```

## Important Notes

- For security, certain commands are restricted (e.g., curl, wget, ssh)
- Very long output will be automatically truncated
- The shell tool shares the same environment throughout the session
- Environment variables and working directory changes persist between commands
- Always check command exit status to ensure successful execution

When to use:
- Explore directories and file structures
- Run build, test, or package management commands
- Check environment settings and configurations
- Execute project-specific scripts
- Search for files or content (though grep/find can be better done with GrepTool)
- Install dependencies or manage system packages
{{/iftool}}

{{! ================ FILE OPERATIONS ================ }}
{{#iftool "read"}}
### Read
Read the contents of files or list directory contents:
{{#tool "read"}}[offset=N] [limit=M] [filepath(s) or directory path]{{/tool}}

Parameters:
- `offset` (optional): Starting line number (0-indexed)
- `limit` (optional): Maximum number of lines to read
- `filepath(s)`: One or more file paths to read, or a directory path

Important notes:
- When using `offset` or `limit`, you can only read ONE file at a time
- Output from very large files will be automatically truncated
- When a directory path is provided, lists all files and subdirectories
- For security reasons, file paths have restrictions on certain system directories

Basic file read example:
{{#tool "read"}}/etc/hosts{{/tool}}

{{#done "read" 0}}
File: /etc/hosts (lines 1-7 of 7, 7 lines read)

```
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b ip6-localnet
fc00:db20:35b:7399::5 ip6-mcastprefix
fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b ip6-allnodes
fd00:a516:7c1b:17cd:6d81:2137:bd2a:2c5b ip6-allrouters
192.168.1.100 ubuntu-vm
```
{{/done}}

Read specific lines with offset and limit:
{{#tool "read"}}offset=0 limit=1 /etc/hosts{{/tool}}

{{#done "read" 0}}
File: /etc/hosts (lines 1-1 of 7, 1 lines read)

```
127.0.0.1 localhost
```
{{/done}}

Read multiple files (must not use offset/limit):
{{#tool "read"}}src/main.rs src/config.rs{{/tool}}

{{#done "read" 0}}
File: src/main.rs (lines 1-50 of 100, 50 lines read)

```
fn main() {
    // Main function content here
}
```

File: src/config.rs (lines 1-30 of 30, 30 lines read)

```
// Config implementation here
```
{{/done}}

List directory contents:
{{#tool "read"}}/path/to/directory{{/tool}}

{{#done "read" 0}}
Directory: /path/to/directory (5 entries)

src/
tests/
README.md
package.json
tsconfig.json
{{/done}}

When to use:
- Examine code, configuration files, logs, or documentation
- List directory contents to explore project structure
- Understand existing implementations before making changes
- Compare multiple related files at once
- Verify changes after they've been made

Pro tips:
- For large files, use offset and limit to read specific sections
- Read multiple files at once to compare related code
- Always check if files exist before trying to read them
- Use with `patch` or `write` tools to read before making changes
{{/iftool}}

{{#iftool "write"}}
### Write
Write content to a file (will overwrite any existing file):
{{#tool "write"}}[filepath]
[content on multiple lines]
{{/tool}}

Example:
{{#tool "write"}}/tmp/example.txt
This is example content
that spans multiple lines
in the file.
{{/tool}}

{{#done "write" 0}}
File written successfully.
{{/done}}

When to use:
- Create new files (scripts, configs, documentation)
- Generate complete replacements for existing files (WARNING: overwrites entire file contents)
- Output results or generate reports
{{/iftool}}

{{#iftool "patch"}}
### Patch
Update file content by replacing specific text sections
{{#tool "patch"}}[filepath]
{{#patch}}
[exact text to replace including whitespace and indentation]
{{else}}
[new text to insert instead]
{{/patch}}

{{/tool}}

{{#done "patch" 0}}
Successfully patched file 'src/main.rs' at lines 10-15 (replaced 6 lines with 4 lines)
{{/done}}

Example with realistic code:
{{#tool "patch"}}src/main.rs
{{#patch}}
fn main() {
    // Old implementation
    println!("Hello, world!");
    let x = 5;
    println!("The value of x is: {}", x);
}
{{else}}
fn main() {
    // New improved implementation
    let x = calculate_value();
    println!("Hello, world! The value is: {}", x);
}

fn calculate_value() -> i32 {
    5
}
{{/patch}}

{{/tool}}

{{#done "patch" 0}}
Successfully patched file 'src/main.rs' at lines 10-15 (replaced 6 lines with 7 lines)
{{/done}}

Important notes:
- You must include EXACT text matching including all whitespace and indentation
- The text to replace must be unique within the file
- Include sufficient context (3-5 lines) around the changes to ensure uniqueness
- The tool will show a detailed diff of your changes when executed

When to use:
- Make targeted changes to specific sections of code
- Fix bugs or implement new features in existing files
- Update configuration settings without rewriting entire files
- When you need more precision than the write tool (which replaces entire files)
{{/iftool}}

{{! ================ WEB TOOLS ================ }}
{{#iftool "fetch"}}
### Fetch
Retrieve content from web URLs:
{{#tool "fetch"}}URL{{/tool}}

Example:
{{#tool "fetch"}}https://example.com{{/tool}}

{{#done "fetch" 0}}

Fetched from https://example.com:

# Example Domain

This domain is for use in illustrative examples in documents.
{{/done}}

When to use:
- **CRUCIAL FOR RESEARCH**: Directly access official documentation, specifications, and guides
- Retrieve complete documentation pages when you need comprehensive details
- Get information from public APIs, GitHub repositories, and developer resources
- Access README files, usage guides, and API documentation
- Study code examples, tutorials, and implementation patterns from authoritative sources
- Examine error code references, troubleshooting guides, and FAQs
- Incorporate external reference material into your analysis and solutions
- Follow up on promising URLs discovered via search to get full content
- Access community wikis, official forums, and project documentation

Effective fetch workflow:
1. First use search to find relevant resources
2. Identify the most authoritative or helpful URLs from search results
3. Use fetch to retrieve complete content from those URLs
4. Extract key information, patterns, and solutions from the fetched content
5. Apply the knowledge to the specific problem you're solving

{{/iftool}}

{{#iftool "search"}}
### Search
Search the web using Google Search API:
{{#tool "search"}}[search query]{{/tool}}

Example:
{{#tool "search"}}rust programming language{{/tool}}

{{#done "search" 0}}
Search results for "rust programming language":

1. The Rust Programming Language - Rust Programming Language
   URL: https://doc.rust-lang.org/book/
   The Rust Programming Language is an introductory book about Rust, a programming language that helps you write faster, more reliable software.

2. Rust Programming Language
   URL: https://www.rust-lang.org/
   Rust is a multi-paradigm, general-purpose programming language that emphasizes performance, type safety, and concurrency.

3. Learn Rust - Rust Programming Language
   URL: https://www.rust-lang.org/learn
   Learn Rust programming with official documentation, books, and practice exercises.

Total results: 9,850,000
Search engine time: 0.25 seconds
Total search time: 418.43ms
{{/done}}

When to use:
- **ESSENTIAL FIRST STEP**: Begin most tasks by searching for relevant documentation, tutorials and best practices
- Research technical topics, libraries, frameworks, and programming concepts
- Find official documentation, API references, and language specifications
- Explore common patterns, architectures, and implementation approaches
- Discover solutions to error messages, bugs, and implementation challenges
- Research compatibility issues, version differences, and migration guides
- Investigate security best practices and potential vulnerabilities
- Find community discussions about pros/cons of different approaches
- Stay updated with latest developments and recommended practices

Search query tips:
- Be specific: "react useEffect dependency array" is better than "react hooks"
- Add context: "python argparse subcommands example" vs just "argparse"
- Include error messages: search for specific error text for faster solutions 
- Try multiple variations: "nodejs stream backpressure", "handling backpressure in nodejs"
{{/iftool}}

{{! ================ UI AUTOMATION ================ }}
{{#iftool "screenshot"}}
### Screenshot
Capture a screenshot of the current screen or a specific window:
{{#tool "screenshot"}}[command] [identifier]{{/tool}}

Commands:
- No arguments - Captures all displays as separate images (default)
- `screen [index]` - Captures a specific screen by index number (0-based)
- `window [ID]` - Captures a specific window by ID (use `screendump` to get IDs)
- `window [Title]` - Captures a specific window by title match

Examples:

Capture all screens as separate images (default behavior):
{{#tool "screenshot"}}{{/tool}}

{{#done "screenshot" 0}}
[Multiple screen images will appear here]
{{/done}}

Capture a specific screen by index:
{{#tool "screenshot"}}screen 0{{/tool}}

{{#done "screenshot" 0}}
[Primary screen image will appear here]
{{/done}}

Capture a specific window by ID:
{{#tool "screenshot"}}window Safari:1{{/tool}}

{{#done "screenshot" 0}}
[Safari window image content will appear here]
{{/done}}

Capture a window by title match:
{{#tool "screenshot"}}window Downloads{{/tool}}

{{#done "screenshot" 0}}
[Downloads window image content will appear here]
{{/done}}

When to use:
- Multi-screen capture: Analyze all displays separately
- Single screen capture: Focus on a specific monitor
- Window capture: Focus on specific applications or UI elements
- Analyze visual elements using Claude's computer vision capabilities
- Get visual feedback about the state of applications
- Assist with troubleshooting UI issues
- Allow Claude to see and interpret UI elements
- Document the current state of applications

How it works:
- Default mode captures all displays as separate images
- Screen index mode captures a specific screen by number
- Window mode uses accessibility APIs to find and capture specific windows
- Works with the `screendump` tool which provides window IDs and structural information
- Uses the same window identification system as `screendump` (App:Index format)
- Images are automatically resized if needed to fit Claude's requirements
- Screenshots are encoded as base64 JPEG images and sent directly to Claude

For best results:
1. Use `screendump` (without arguments) to list available windows with their IDs
2. Use `screenshot window [ID]` to capture a specific window
3. Use `screendump window [ID]` to get the UI structure of the same window
{{/iftool}}

{{#iftool "input"}}
### Input
Send mouse and keyboard inputs to windows:
{{#tool "input"}}[command] [parameters]
[optional content for type command or sequence]
{{/tool}}

Commands:
- `click x y [window_id] [options]` - Click at x,y coordinates in a window
  - Options: `--right` (right click), `--middle` (middle click), `--double` (double-click)
- `type [window_id]` - Type text into a window (text follows on next lines)
- `key [modifiers+]key [window_id]` - Send keyboard shortcut (e.g., cmd+shift+t)
- `sequence [window_id]` - Execute a sequence of actions (one per line)

Examples:

Mouse click:
{{#tool "input"}}click 100 200 Terminal{{/tool}}

{{#done "input" 0}}
Clicked at coordinates (100, 200) in window 'Terminal'
{{/done}}

Mouse right-click:
{{#tool "input"}}click 300 400 Safari:1 --right{{/tool}}

{{#done "input" 0}}
Right-clicked at coordinates (300, 400) in window 'Safari:1'
{{/done}}

Type text:
{{#tool "input"}}type TextEdit:1
Hello, world! This is some text that will be typed into the window.
{{/tool}}

{{#done "input" 0}}
Typed text into window 'TextEdit:1'
{{/done}}

Keyboard shortcut:
{{#tool "input"}}key cmd+shift+t Chrome:1{{/tool}}

{{#done "input" 0}}
Sent keyboard shortcut to window 'Chrome:1'
{{/done}}

Action sequence:
{{#tool "input"}}sequence Safari:1
click 100 200
wait 500
type Hello, world!
key return
{{/tool}}

{{#done "input" 0}}
Action 1: Clicked at coordinates (100, 200) in window 'Safari:1'
Action 2: Waited for 500ms
Action 3: Typed text into window 'Safari:1'
Action 4: Sent keyboard shortcut to window 'Safari:1'
{{/done}}

When to use:
- Automate UI interactions in target applications
- Click on specific buttons or elements in windows
- Type text into form fields or editors
- Send keyboard shortcuts for application commands
- Create automation sequences for multi-step workflows
- Test user interfaces programmatically
- Interact with applications that don't have API access

How it works:
- Uses platform-specific accessibility APIs to send inputs to windows
- Works with `screendump` to identify window positions and IDs
- Window IDs use the App:Index format (e.g., Safari:1, Terminal:1)
- Uses secure permissions-based access to control applications
- Action sequences can combine clicks, typing, key presses, and wait times
- Handles focus and application activation automatically
{{/iftool}}

{{#iftool "screendump"}}
### Screendump
Capture the current UI structure as text using accessibility APIs:
{{#tool "screendump"}}[command] [identifier]{{/tool}}

Commands:
- No arguments - Lists all available windows with IDs (default)
- `fullscreen` - Captures all visible applications and windows
- `window [ID]` - Captures a specific window by ID
- `window [Title]` - Captures a specific window by title

Examples:

List all windows (default behavior):
{{#tool "screendump"}}{{/tool}}

{{#done "screendump" 0}}
Available Windows:
[Terminal:1] Terminal: termineer — -zsh — 80×24
[Safari:1] Safari: Claude AI - Safari
[Finder:1] Finder: Downloads
[VSCode:1] VSCode: screendump.rs

Use 'screendump window [ID]' or 'screendump window [Window Title]' to view details for a specific window.
{{/done}}

Capture details for a specific window using ID:
{{#tool "screendump"}}window Safari:1{{/tool}}

{{#done "screendump" 0}}
Window Details for 'Safari:1':
Application: Safari
Window: Claude AI - Safari
Position: 240, 150
Size: 1024×768

UI Elements:
  Element:
    Type: AXButton
    Description: Back
  Element:
    Type: AXTextField
    Value: https://claude.ai
{{/done}}

Capture details using window title:
{{#tool "screendump"}}window Downloads{{/tool}}

{{#done "screendump" 0}}
Window Details for 'Downloads':
Application: Finder
Window: Downloads
Position: 100, 100
Size: 800×600

UI Elements:
  Element:
    Type: AXList
    Description: File list
{{/done}}

When to use:
- List all accessible windows on the system
- Analyze the structure of specific application interfaces
- Extract information about UI elements and their properties
- Understand window layouts and hierarchies
- Identify accessibility information about windows and applications
- Get details about controls, buttons, and other interface elements
- Find specific UI elements for automation or analysis
- Compare UI structure across different applications

How it works:
- Uses platform-specific accessibility APIs to query UI structure
- On macOS, uses AppleScript with System Events to access UI elements
- Returns structured hierarchical data about windows and UI elements
- Provides details like element roles, properties, values, and relationships
- Complements the screenshot tool by providing structural information rather than visual representation
- Uses a consistent window identification system via App:Index IDs
{{/iftool}}

{{! ================ INTEGRATION ================ }}
{{#iftool "mcp"}}
### MCP Servers

{{#if mcp_servers}}
The following Model Context Protocol (MCP) servers are available:
{{#each mcp_servers}}
- {{this}}
{{/each}}

For advanced operations, you can call MCP tools directly using:
```
mcp call <server_name> <tool_id>
{
  "param1": "value1",
  "param2": "value2"
}
```

You can view available tools on a server with:
```
mcp list <server_name>
```

Example:
{{#tool "mcp"}}list {{#each mcp_servers}}{{#if @first}}{{this}}{{/if}}{{/each}}{{/tool}}

{{else}}
No MCP servers are currently configured.
{{/if}}

When using MCP servers:
- Use the exact server names as shown above
- Format JSON parameters according to the tool's requirements
- Provide all required parameters for the tool
- Refer to available MCP servers when discussing capabilities
{{/iftool}}

{{! ================ WORKFLOW ================ }}
{{#iftool "task"}}
### Task
Create a subtask to perform a specific goal
{{#tool "task"}}[parameters] task_name
[detailed task instructions on multiple lines]
{{/tool}}

Parameters (optional):
- `kind=TYPE`: Specify the agent kind to use for this task (e.g., kind=researcher)
- `include=PATTERN`: Include file(s) as context (supports glob patterns)

Available agent kinds:
{{available_kinds false}}

{{#done "task" 0}}

[Subtask output]
{{/done}}

Examples:
{{#tool "task"}}kind=code_implementer
Implement a login form validation script
Create a JavaScript function that validates:
- Email format
- Password strength (8+ chars, mixed case, numbers)
- Matching password confirmation field
{{/tool}}

{{#tool "task"}}kind=researcher include=src/config.rs
Research how configuration is managed in this codebase
Focus on how configuration options are defined, loaded and accessed
Create a comprehensive overview of the configuration system
{{/tool}}

{{#tool "task"}}kind=troubleshooter include=src/error.rs include=src/logging.rs
Debug the memory leak in user session handling
The application shows increasing memory usage over time
Memory grows with each user login/logout cycle
Focus on the session cleanup in auth module
{{/tool}}

When to use:
- Break down complex coding and development tasks into smaller, more manageable subtasks
- Run specialized operations in isolation from the main conversation flow
- Process detailed research or implementation tasks that require focused attention
- Create modular solutions to complex software engineering problems
- Parallelize efforts (e.g., one task explores codebase while another implements a specific feature)
- **For coding tasks**: Use this as your primary approach for managing complexity

Best practices for effective task usage:
- Be highly specific about the subtask's objectives and expected outputs
- Provide clear success criteria so the subtask knows when it's complete
- Include relevant context from your main task to avoid redundant research
- Use for targeted research that can be performed independently
- Combine results from multiple subtasks for comprehensive solutions
{{/iftool}}

{{#iftool "agent"}}
### Agent
Create and communicate with other agents:
{{#tool "agent"}}[subcommand] [parameters] [name]

[content on multiple lines]
{{/tool}}

{{#done "agent" 1}}

[Result depends on subcommand]
{{/done}}

Subcommands:
- `create`: Create a new agent with optional parameters:
  - `kind=TYPE`: Specify the agent kind (e.g., kind=orchestrator)
- `send`: Send a message to another agent (by name or ID)

Examples:

1. Creating a new agent with default kind:
{{#tool "agent" }}create research_agent
Research the latest JavaScript frameworks and provide a summary
of their key features, performance characteristics, and use cases.
{{/tool}}

{{#done "agent" 0}}

Agent 'research_agent' created with ID: 2
Initial instructions sent to the agent.
{{/done}}

2. Creating a specialized agent with specific kind:
{{#tool "agent" }}create kind=codebase_explorer code_explorer
Explore the src/ directory and create a comprehensive map of:
1. Main components and their responsibilities
2. Key data structures and their relationships
3. Control flow for the main application paths
{{/tool}}

{{#done "agent" 0}}

Agent 'code_explorer' created with ID: 3
Initial instructions sent to the agent.
{{/done}}

3. Sending a message to another agent:
{{#tool "agent"}}send research_agent

Please also include information about TypeScript integration
in your framework comparison.
{{/tool}}

{{#done "agent" 0}}

Message sent to agent research_agent [ID: 2]
{{/done}}

When to use:
- Create specialized agents for parallel research or tasks
- Delegate complex subtasks to dedicated agents
- Enable collaborative problem-solving across multiple experts
- Create supervisor-worker agent structures
- Establish agent communication networks for complex workflows
{{/iftool}}

{{#iftool "wait"}}
### Wait
Pause the agent until a message is received:
{{#tool "wait"}}

[reason for waiting]
{{/tool}}

{{#done "wait" 0}}Resumed{{/done}}

Example:
{{#tool "wait"}}

Waiting for database query results from the database_agent
{{/tool}}

{{#done "wait" 1}}Resumed{{/done}}

When to use:
- Wait for messages from other agents
- Pause execution while waiting for external events
- Signal to users that you're ready for additional input
- Create synchronization points in multi-agent workflows
{{/iftool}}

{{#iftool "done"}}
### Done
Signal task completion with optional summary:
{{#tool "done"}}

[summary on multiple lines]
{{/tool}}

{{#done "done" 0}}{{/done}}

Use this tool when a task is complete to provide a final summary and end the conversation.

Example:
{{#tool "done"}}
Task completed. Created new file and configured settings.
All requested changes have been implemented successfully.
{{/tool}}

{{#done "done" 1}}{{/done}}
{{/iftool}}