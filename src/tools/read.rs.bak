use std::iter::once;
use crate::constants::{FORMAT_BOLD, FORMAT_GRAY, FORMAT_RESET, FORMAT_YELLOW};
use crate::tools::{AgentStateChange, ToolResult};
use tokio::fs;

/// Maximum number of lines the read tool can read at once.
/// This prevents loading extremely large files into the conversation
/// which could overwhelm token limits or make the UI unresponsive.
/// When this limit is reached, truncation notices are shown with
/// instructions on how to access additional content.
const MAX_READABLE_LINES: usize = 1000;

/// Struct to hold parsed arguments for the read tool
struct ReadArgs {
    offset: Option<usize>,
    limit: Option<usize>,
    paths: Vec<String>,
}

pub async fn execute_read(args: &str, _body: &str, silent_mode: bool) -> ToolResult {
    // Note: For read tool, we mainly use args, not body
    // Parse arguments
    let parsed_args = parse_arguments(args);

    // Handle empty paths case
    if parsed_args.paths.is_empty() {
        let error_msg = "No files specified for reading".to_string();

        if !silent_mode {
            // Use output buffer for error messages
            bprintln !(error:"{}", error_msg);
        }

        return ToolResult::error(error_msg);
    }

    // If offset or limit is specified, only read a single file
    if parsed_args.offset.is_some() || parsed_args.limit.is_some() {
        if parsed_args.paths.len() > 1 {
            let error_msg =
                "Offset and limit parameters can only be used with a single file".to_string();

            if !silent_mode {
                // Use buffer-based printing
                bprintln !(error:"{}", error_msg);
            }

            return ToolResult::error(error_msg);
        }
        return read_single_file(
            &parsed_args.paths[0],
            parsed_args.offset,
            parsed_args.limit,
            silent_mode,
        )
        .await;
    }

    // If there's only one path, use the single file/directory approach
    if parsed_args.paths.len() == 1 {
        return read_single_file(&parsed_args.paths[0], None, None, silent_mode).await;
    }

    // Multiple files case
    read_multiple_files(&parsed_args.paths, silent_mode).await
}

/// Parse the command arguments into a structured format
fn parse_arguments(args: &str) -> ReadArgs {
    let mut offset: Option<usize> = None;
    let mut limit: Option<usize> = None;
    let mut remaining_args = args.trim().to_string();

    // Extract offset parameter
    if let Some(offset_idx) = remaining_args.find("offset=") {
        let offset_start = offset_idx + 7; // Length of "offset="
        let offset_end = find_param_end(&remaining_args[offset_start..])
            .map_or(remaining_args.len(), |end| offset_start + end);

        if let Ok(val) = remaining_args[offset_start..offset_end]
            .trim()
            .parse::<usize>()
        {
            offset = Some(val);
        }

        // Remove the parameter from the string
        remaining_args = format!(
            "{} {}",
            &remaining_args[..offset_idx].trim(),
            &remaining_args[offset_end..].trim()
        )
        .trim()
        .to_string();
    }

    // Extract limit parameter
    if let Some(limit_idx) = remaining_args.find("limit=") {
        let limit_start = limit_idx + 6; // Length of "limit="
        let limit_end = find_param_end(&remaining_args[limit_start..])
            .map_or(remaining_args.len(), |end| limit_start + end);

        if let Ok(val) = remaining_args[limit_start..limit_end]
            .trim()
            .parse::<usize>()
        {
            limit = Some(val);
        }

        // Remove the parameter from the string
        remaining_args = format!(
            "{} {}",
            &remaining_args[..limit_idx].trim(),
            &remaining_args[limit_end..].trim()
        )
        .trim()
        .to_string();
    }

    // Split remaining arguments into paths
    let paths: Vec<String> = remaining_args
        .split_whitespace()
        .map(|s| s.to_string())
        .collect();

    ReadArgs {
        offset,
        limit,
        paths,
    }
}

/// Helper function to find the end of a parameter value
fn find_param_end(s: &str) -> Option<usize> {
    s.find(|c: char| c.is_whitespace())
}

/// Read multiple files and combine their outputs
async fn read_multiple_files(filepaths: &[String], silent_mode: bool) -> ToolResult {
    let mut agent_outputs = Vec::new();
    let mut all_successful = true;

    for filepath in filepaths {
        let result = read_file_content(filepath, None, None, silent_mode).await;
        agent_outputs.push(result.to_text());
        if !result.success {
            all_successful = false;
        }
    }

    let combined_agent_output = agent_outputs.join("\n\n");

    // Print combined output message if not in silent mode
    if !silent_mode {
        // Use buffer-based printing
        bprintln !(tool: "read",
            "{}📚 Read {} files:{}",
            FORMAT_BOLD,
            filepaths.len(),
            FORMAT_RESET
        );

        // Optionally, we could print more details about each file here
    }

    ToolResult {
        success: all_successful,
        state_change: AgentStateChange::Continue,
        content: vec![crate::llm::Content::Text {
            text: combined_agent_output,
        }],
    }
}

/// Helper function to read a single file or directory path
async fn read_single_file(
    filepath: &str,
    offset: Option<usize>,
    limit: Option<usize>,
    silent_mode: bool,
) -> ToolResult {
    // Validate path to prevent path traversal attacks
    let validated_path = match crate::tools::path_utils::validate_path(filepath) {
        Ok(path) => path,
        Err(e) => {
            let error_msg = format!("Security error: '{}': {}", filepath, e);

            if !silent_mode {
                // Use output buffer for error messages
                bprintln !(error:"{}", error_msg);
            }

            return ToolResult::error(error_msg);
        }
    };

    // Get the path as a reference
    let path = validated_path.as_path();

    // Check if path exists
    if !fs::try_exists(path).await.unwrap_or(false) {
        let error_msg = format!("Error: Path does not exist: '{}'", filepath);

        if !silent_mode {
            // Use output buffer for error messages
            bprintln !(error:"{}", error_msg);
        }

        return ToolResult::error(error_msg);
    }

    // Check if path is a directory
    if fs::metadata(path)
        .await
        .map(|m| m.is_dir())
        .unwrap_or(false)
    {
        // Important: Use the validated path object, not the original string
        return read_directory(&validated_path.to_string_lossy(), silent_mode).await;
    }

    // Handle regular file - use the validated path, not the original string
    read_file_content(
        &validated_path.to_string_lossy(),
        offset,
        limit,
        silent_mode,
    )
    .await
}

/// Helper function to read file content with optional offset and limit
async fn read_file_content(
    filepath: &str,
    offset: Option<usize>,
    limit: Option<usize>,
    silent_mode: bool,
) -> ToolResult {
    // Validate file path to prevent path traversal attacks
    // (this validation may be redundant if called from read_single_file with validated path,
    // but we keep it for safety in case this function is called directly)
    let validated_path = match crate::tools::path_utils::validate_path(filepath) {
        Ok(path) => path,
        Err(e) => {
            let error_msg = format!("Security error for file '{}': {}", filepath, e);

            if !silent_mode {
                // Use output buffer for error messages
                bprintln !(error:"{}", error_msg);
            }

            return ToolResult::error(error_msg);
        }
    };

    match fs::read_to_string(&validated_path).await {
        Ok(content) => {
            // Split content into lines
            let lines: Vec<&str> = content.lines().collect();
            let total_lines = lines.len();

            // Apply offset and limit
            let start_line = offset.unwrap_or(0).min(total_lines);
            
            // Determine the requested end line based on the limit parameter or full file
            let requested_end_line = match limit {
                Some(l) => (start_line + l).min(total_lines),
                None => total_lines,
            };
            
            // Check if we need to truncate due to MAX_READABLE_LINES
            let was_truncated = (requested_end_line - start_line) > MAX_READABLE_LINES;
            
            // Apply the maximum line limit
            let end_line = if was_truncated {
                start_line + MAX_READABLE_LINES
            } else {
                requested_end_line
            };

            // Extract the requested lines
            let selected_lines = lines[start_line..end_line].join("\n");
            let lines_read = end_line - start_line;

            // Get the display path from the validated path
            let safe_display_path = validated_path.to_string_lossy();

            // Format the output to clearly indicate line numbers and truncation if it occurred
            let truncation_notice = if was_truncated {
                format!("\n\n{} TRUNCATION NOTICE {}\nFile content was truncated to {} lines maximum.\nTo read additional content, use offset parameter:\n  read offset={} limit=1000 {}\n", 
                    "=".repeat(15), 
                    "=".repeat(15),
                    MAX_READABLE_LINES,
                    start_line + MAX_READABLE_LINES,
                    safe_display_path
                )
            } else {
                String::new()
            };
            
            let agent_output = format!(
                "File: {} (lines {}-{} of {}, {} lines read{})\n\n```\n{}\n```{}",
                safe_display_path,
                start_line + 1,
                end_line,
                total_lines,
                lines_read,
                if was_truncated { ", truncated" } else { "" },
                selected_lines,
                truncation_notice
            );

            // Direct output to console if not in silent mode
            if !silent_mode {
                // Create a brief preview for console output
                let preview_lines = lines[start_line..end_line]
                    .iter()
                    .take(2)
                    .map(ToString::to_string)
                    .chain(once(format!("+ {} lines", end_line.saturating_sub(start_line).saturating_sub(2))))
                    .map(|line| format!("{}{}{}", FORMAT_GRAY, line, FORMAT_RESET))
                    .collect::<Vec<String>>()
                    .join("\n");

                // Use output buffer for read tool output
                if !preview_lines.is_empty() {
                    let truncated_mark = if was_truncated {
                        format!(" {}{}{}", FORMAT_YELLOW, "⚠️ TRUNCATED", FORMAT_RESET)
                    } else {
                        String::new()
                    };
                    
                    bprintln !(tool: "read",
                        "{}📄 Read: {} (lines {}-{} of {} total){}{}{}{}",
                        FORMAT_BOLD,
                        safe_display_path,
                        start_line + 1,
                        end_line,
                        total_lines,
                        truncated_mark,
                        FORMAT_RESET,
                        "\n",
                        preview_lines
                    );
                } else {
                    let truncated_mark = if was_truncated {
                        format!(" {}{}{}", FORMAT_YELLOW, "⚠️ TRUNCATED", FORMAT_RESET)
                    } else {
                        String::new()
                    };
                    
                    bprintln !(tool: "read",
                        "{}📄 Read: {} (lines {}-{} of {} total){}{}",
                        FORMAT_BOLD,
                        safe_display_path,
                        start_line + 1,
                        end_line,
                        total_lines,
                        truncated_mark,
                        FORMAT_RESET
                    );
                }
                
                // Add detailed truncation notice to console output if needed
                if was_truncated {
                    bprintln !(tool: "read",
                        "{}⚠️  File too large: content truncated to {} lines maximum.{}",
                        FORMAT_YELLOW,
                        MAX_READABLE_LINES,
                        FORMAT_RESET
                    );
                    bprintln !(tool: "read",
                        "{}   To read more, use: read offset={} limit=1000 {}{}",
                        FORMAT_YELLOW,
                        start_line + MAX_READABLE_LINES,
                        safe_display_path,
                        FORMAT_RESET
                    );
                }
            }

            ToolResult::success(agent_output)
        }
        Err(e) => {
            let error_msg = format!("Error reading file '{}': {}", filepath, e);

            if !silent_mode {
                // Use buffer-based printing
                bprintln !(error:"{}", error_msg);
            }

            ToolResult::error(error_msg)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use tokio::fs::File;
    use tokio::io::AsyncWriteExt;

    // Helper function to create a test file with a specific number of lines
    async fn create_test_file(path: &Path, line_count: usize) -> std::io::Result<()> {
        let mut file = File::create(path).await?;
        for i in 1..=line_count {
            file.write_all(format!("This is line {} in the test file\n", i).as_bytes()).await?;
        }
        Ok(())
    }

    #[tokio::test]
    async fn test_read_limits() {
        // Create a temporary directory for test files
        let temp_dir = tempfile::tempdir().unwrap();
        let file_path = temp_dir.path().join("large_file.txt");
        
        // Create a test file with 1500 lines (exceeding the 1000 line limit)
        create_test_file(&file_path, 1500).await.unwrap();
        
        // Test reading the file without offset/limit
        let result = read_file_content(&file_path.to_string_lossy(), None, None, false).await;
        
        // Verify the result is successful
        assert!(result.success);
        
        // Extract the text content from the result
        let text = if let crate::llm::Content::Text { text } = &result.content[0] {
            text
        } else {
            panic!("Expected text content");
        };
        
        // The output should show it's truncated
        assert!(text.contains("lines read, truncated"));
        
        // The output should contain exactly MAX_READABLE_LINES lines of content plus metadata
        let lines_in_output = text.lines().count();
        // +5 accounts for the metadata lines, header, code block markers, and truncation notice
        assert!(lines_in_output >= MAX_READABLE_LINES && lines_in_output <= MAX_READABLE_LINES + 10);
        
        // Output should contain the truncation notice
        assert!(text.contains("TRUNCATION NOTICE"));
        assert!(text.contains(&format!("truncated to {} lines maximum", MAX_READABLE_LINES)));
        
        // Should suggest using offset parameter
        assert!(text.contains(&format!("offset={} limit=1000", MAX_READABLE_LINES)));
        
        // Test reading with offset to get the next chunk
        let result = read_file_content(
            &file_path.to_string_lossy(), 
            Some(MAX_READABLE_LINES), 
            Some(1000), 
            false
        ).await;
        
        // Verify success and content
        assert!(result.success);
        
        let text = if let crate::llm::Content::Text { text } = &result.content[0] {
            text
        } else {
            panic!("Expected text content");
        };
        
        // Should show the correct offset in the output
        assert!(text.contains(&format!("lines {}-", MAX_READABLE_LINES + 1)));
        
        // Verify we get the remaining lines
        assert!(text.contains(&format!("This is line {}", MAX_READABLE_LINES + 1)));
    }
}

/// Helper function to list directory contents
async fn read_directory(dirpath: &str, silent_mode: bool) -> ToolResult {
    // Validate directory path to prevent path traversal attacks
    // (this validation may be redundant if called from read_single_file with validated path,
    // but we keep it for safety in case this function is called directly)
    let validated_path = match crate::tools::path_utils::validate_directory(dirpath) {
        Ok(path) => path,
        Err(e) => {
            let error_msg = format!("Security error for directory '{}': {}", dirpath, e);

            if !silent_mode {
                // Use output buffer for error messages
                bprintln !(error:"{}", error_msg);
            }

            return ToolResult::error(error_msg);
        }
    };

    // Get the display path from the validated path
    let safe_display_path = validated_path.to_string_lossy();

    match fs::read_dir(&validated_path).await {
        Ok(mut entries) => {
            let mut files = Vec::new();
            let mut dirs = Vec::new();

            // Collect directory entries
            while let Ok(Some(entry)) = entries.next_entry().await {
                if let Ok(file_type) = entry.file_type().await {
                    if let Ok(filename) = entry.file_name().into_string() {
                        if file_type.is_dir() {
                            dirs.push(format!("{}/", filename));
                        } else {
                            files.push(filename);
                        }
                    }
                }
            }

            // Sort entries alphabetically
            dirs.sort();
            files.sort();

            // Combine directories and files
            let all_entries = [&dirs[..], &files[..]].concat();
            let entry_count = all_entries.len();
            let content = all_entries.join("\n");

            // Format output for agent, using safe display path
            let agent_output = format!(
                "Directory: {} ({} entries)\n\n{}",
                safe_display_path, entry_count, content
            );

            // Direct output to console if not in silent mode
            if !silent_mode {
                // Build directory output string directly
                let mut output = format!(
                    "{}📁 Directory: {} ({} items){}\n",
                    FORMAT_BOLD, safe_display_path, entry_count, FORMAT_RESET
                );

                // Add directories with trailing slash and bold formatting
                for dir in &dirs {
                    let dir_name = dir.trim_end_matches('/');
                    output.push_str(&format!(
                        "{}{}{}/{}\n",
                        FORMAT_BOLD, FORMAT_GRAY, dir_name, FORMAT_RESET
                    ));
                }

                // Add files
                for file in &files {
                    output.push_str(&format!("{}{}{}\n", FORMAT_GRAY, file, FORMAT_RESET));
                }

                // Use buffer-based printing
                bprintln !(tool: "read", "{}", output.trim_end());
            }

            ToolResult {
                success: true,
                state_change: Default::default(),
                content: vec![crate::llm::Content::Text { text: agent_output }],
            }
        }
        Err(e) => {
            let error_msg = format!("Error reading directory '{}': {}", safe_display_path, e);

            if !silent_mode {
                // Use buffer-based printing
                bprintln !(error:"{}", error_msg);
            }

            ToolResult::error(error_msg)
        }
    }
}

#[cfg(test)]
